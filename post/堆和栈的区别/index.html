
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>堆和栈的区别 | 坦吉</title>
<meta name="description" content="温故而知新">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://supertange.github.io/favicon.ico?v=1577512919515">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://supertange.github.io/styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://supertange.github.io">
        <img class="avatar" src="https://supertange.github.io/images/avatar.png?v=1577512919515" alt="" width="32px" height="32px">
      </a>
      <a href="https://supertange.github.io">
        <h1 class="site-title">坦吉</h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">堆和栈的区别</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2017-01-12</span>
            
              <span>
                <i class="icon-pricetags-outline"></i>
                
                  <a href="https://supertange.github.io/tag/T-FN0lgT0">
                    数据结构与算法分析
                    
                  </a>
                
              </span>
            
          </div>
          <div class="post-content">
            <h2 id="概念">概念</h2>
<p>1、栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  <!--more--><br>
2、堆区（heap）   —   一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。<br>
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。-程序结束后由系统释放。<br>
4、文字常量区   —常量字符串就是放在这里的。   程序结束后由系统释放<br>
5、程序代码区—存放函数体的二进制代码。</p>
<h2 id="特点">特点</h2>
<p>栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：<br>
复制内容到剪贴板代码:<br>
int a = 3;<br>
int b = 3；<br>
编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。<br>
通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，-一个ID为“未婚人士”的用户发贴，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。</p>
<h2 id="申请后系统的响应">申请后系统的响应</h2>
<h5 id="栈只要栈的剩余空间大于所申请空间系统将为程序提供内存否则将报异常提示栈溢出">栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</h5>
<h5 id="堆首先应该知道操作系统有一个记录空闲内存地址的链表当系统收到程序的申请时-会遍历该链表寻找第一个空间大于所申请空间的堆结点然后将该结点从空闲结点链表中删除并将该结点的空间分配给程序另外对于大多数系统会在这块内存空间中的首地址处记录本次分配的大小这样代码中的delete语句才能正确的释放本内存空间-另外由于找到的堆结点的大小不一定正好等于申请的大小系统会自动的将多余的那部分重新放入空闲链表中">堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，    会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。    另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</h5>
<h2 id="申请大小的限制">申请大小的限制</h2>
<h5 id="栈在windows下栈是向低地址扩展的数据结构是一块连续的内存的区域-这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的在windows下栈的大小是2m也有-的说是1m总之是一个编译时就确定的常数如果申请的空间超过栈的剩余空间时将提示overflow-因此能从栈获得的空间较小">栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有    的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</h5>
<h5 id="堆堆是向高地址扩展的数据结构是不连续的内存区域-这是由于系统是用链表来存储的空闲内存地址的自然是不连续的而链表的遍历方向是由低地址向高地址-堆的大小受限于计算机系统中有效的虚拟内存-由此可见堆获得的空间比较灵活也比较大">堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</h5>
<h2 id="申请效率的比较">申请效率的比较：</h2>
<h5 id="栈由系统自动分配速度较快-但程序员是无法控制的">栈由系统自动分配，速度较快。但程序员是无法控制的。</h5>
<h5 id="堆是由new分配的内存一般速度比较慢而且容易产生内存碎片不过用起来最方便">堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</h5>
<h5 id="在windows下最好的方式是用virtualalloc分配内存他不是在堆也不是在栈是直接在进程的地址空间中保留一块内存虽然用起来最不方便-但是速度快也最灵活">在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</h5>
<h2 id="堆和栈中的存储内容">堆和栈中的存储内容</h2>
<h5 id="栈-在函数调用时第一个进栈的是主函数中后的下一条指令函数调用语句的下一条可执行语句的地址然后是函数的各个参数在大多数的c编译器中参数是由右往左入栈的然后是函数中的局部变量-注意静态变量是不入栈的-当本次函数调用结束后局部变量先出栈然后是参数最后栈顶指针指向最开始存的地址也就是主函数中的下一条指令程序由该点继续运行">栈：   在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。      当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</h5>
<h5 id="堆一般是在堆的头部用一个字节存放堆的大小-堆中的具体内容由程序员安排">堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</h5>
<h2 id="存取效率的比较">存取效率的比较</h2>
<pre><code>
         char   s1[]   =   &quot;aaaaaaaaaaaaaaa&quot;;

         char   *s2   =   &quot;bbbbbbbbbbbbbbbbb&quot;;
         
         
</code></pre>
<pre><code>     aaaaaaaaaaa是在运行时刻赋值的；

     而bbbbbbbbbbb是在编译时就确定的；

    但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。

    比如：
</code></pre>
<pre><code>

        #include

        void   main()

        {

        char   a   =   1;

        char   c[]   =   &quot;1234567890&quot;;

        char   *p   =&quot;1234567890&quot;;

        a   =   c[1];

        a   =   p[1];

        return;

         }
         
         
</code></pre>
<pre><code>  对应的汇编代码
</code></pre>
<pre><code>
      10:   a   =   c[1];

      00401067   8A   4D   F1   mov   cl,byte   ptr   [ebp-0Fh]

      0040106A   88   4D   FC   mov   byte   ptr   [ebp-4],cl      11:   a   =   p[1];

      0040106D   8B   55   EC   mov   edx,dword   ptr   [ebp-14h]

      00401070   8A   42   01   mov   al,byte   ptr   [edx+1]

      00401073   88    45   FC   mov   byte   ptr   [ebp-4],al
</code></pre>
<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读      到edx中，再根据edx读取字符，显然慢了。</p>
<h4 id="堆和栈的区别可以用如下的比喻来看出">堆和栈的区别可以用如下的比喻来看出：</h4>
<h6 id="使用栈就象我们去饭馆里吃饭只管点菜发出申请-付钱-和吃使用吃饱了就走不必理会切菜-洗菜等准备工作和洗碗-刷锅等扫尾工作他的好处是快捷但是自由度小">使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</h6>
<h6 id="使用堆就象是自己动手做喜欢吃的菜肴比较麻烦但是比较符合自己的口味而且自由度大">使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</h6>
<p>文章参考以下链接➡️<br>
如需进一步了解，请访问<a href="http://blog.csdn.net/hairetz/article/details/4141043">堆和栈的区别</a></p>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://supertange.github.io/post/c语言二级基础内容">
              <h3 class="post-title">
                下一篇：c语言二级基础内容
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">温故而知新</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
  Powered by Tange | <a class="rss" href="https://supertange.github.io/atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
